/**
 * @file   sensor_remapper.cpp
 * @author Robert Krug
 * @date   Fri Feb 24, 2012
 *
 */
#include <ros/ros.h>
#include <string>
#include "sensor_remapper/sensor_remapper.h"
#include "icr_msgs/ContactState.h"
#include <Eigen/Core>
#include <Eigen/Geometry>
#include <math.h>

//-------------------------------------------------------------------
SensorRemapper::SensorRemapper() : nh_private_("~")
{
 std::string searched_param;
 XmlRpc::XmlRpcValue sensor_topics;

   if (nh_private_.searchParam("sensor_topics", searched_param))
     {
       nh_.getParam(searched_param,sensor_topics);
       ROS_ASSERT(sensor_topics.getType() == XmlRpc::XmlRpcValue::TypeArray); 
    
       for (int32_t i = 0; i < sensor_topics.size(); ++i) 
  	{    
  	 ROS_ASSERT(sensor_topics[i]["name"].getType() == XmlRpc::XmlRpcValue::TypeString);
         ROS_ASSERT(sensor_topics[i]["type"].getType() == XmlRpc::XmlRpcValue::TypeString);
         ROS_ASSERT(sensor_topics[i]["remap_name"].getType() == XmlRpc::XmlRpcValue::TypeString);

	 sensor_subs_.push_back(createSubscriber((std::string)sensor_topics[i]["name"],(std::string)sensor_topics[i]["type"],i));
	 c_state_pubs_.push_back(nh_.advertise<icr_msgs::ContactState> ((std::string)sensor_topics[i]["remap_name"], 1));
       }
    }
  else
    {
      ROS_ERROR("The sensor remapping configurations are not specified - cannot start the Sensor remapper");
      exit(0);
    }

}
//-------------------------------------------------------------------
ros::Subscriber SensorRemapper::createSubscriber(std::string const & name, std::string const & type, unsigned int topic_id)
{
  ros::Subscriber sub;

  if (!strcmp(type.c_str(),"gazebo_msgs/ContactsState"))
    sub=nh_.subscribe<gazebo_msgs::ContactsState>(name, 1, boost::bind(&SensorRemapper::remapGazeboMsgsContactsState, this,_1,topic_id));
  else if (!strcmp(type.c_str(),"kcl_msgs/KCL_ContactStateStamped"))
    sub=nh_.subscribe<kcl_msgs::KCL_ContactStateStamped>(name, 1, boost::bind(&SensorRemapper::remapKclMsgsKclContactStateStamped, this,_1,topic_id));
  else
    ROS_WARN("%s is an unregistered message type - cannot remap topic %s.",type.c_str(),name.c_str());

  return sub;
}
//-------------------------------------------------------------------
void SensorRemapper::remapGazeboMsgsContactsState(gazebo_msgs::ContactsState::ConstPtr msg, unsigned int topic_id)
{
  icr_msgs::ContactState state;
  ROS_WARN("Remapping of gazebo_msgs/ContactsState not implemented yet - publishing zero valued message");

  //TODO Put the stuff from the phalange class here

	//Contact position is generated by averaging over all points in the message
  //	tf::pointTFToMsg(averageVectors(cts_st->states[i].contact_positions),C_T_L->contact_pose.pose.position);
        //Contact pose is generated via projecting the pose of the link frame on the nullspace of
        //the average normal specified in the message
  //	tf::quaternionTFToMsg(projectPose(averageVectors(cts_st->states[i].contact_normals)).normalize(),C_T_L->contact_pose.pose.orientation);




  c_state_pubs_[topic_id].publish(state);
}
//-------------------------------------------------------------------
void SensorRemapper::remapKclMsgsKclContactStateStamped(kcl_msgs::KCL_ContactStateStamped::ConstPtr msg, unsigned int topic_id)
{
  icr_msgs::ContactState state;
  state.header.stamp=msg->header.stamp;
  state.header.frame_id=msg->header.frame_id;

  if(pow(msg->contact_normal.x,2)+pow(msg->contact_normal.y,2)+ pow(msg->contact_normal.z,2) < 1.0e-5)
    {
      state.info="not_touching";
      c_state_pubs_[topic_id].publish(state);
      return;
    }
  state.info="touching";
  state.contact_normal.x = -msg->contact_normal.x; //normal points towards the sensor in the KCL_ContactStateStamped messages
  state.contact_normal.y = -msg->contact_normal.y;
  state.contact_normal.z = -msg->contact_normal.z;
  state.contact_position.x = msg->contact_position.x;
  state.contact_position.y = msg->contact_position.y;
  state.contact_position.z = msg->contact_position.z;

  //Compute total force by adding the (outwards pointing) normal force and the tangential force
  Eigen::Vector3d force(msg->tangential_force.x+msg->contact_normal.x*msg->Fnormal,msg->tangential_force.y+msg->contact_normal.y*msg->Fnormal,msg->tangential_force.z+msg->contact_normal.z*msg->Fnormal);
  //Torque resulting by the cross product of force and position
  Eigen::Vector3d torque(Eigen::Vector3d(msg->contact_position.x,msg->contact_position.y,msg->contact_position.z).cross(force));  
  //Add the torque acting around the (outwards pointing) normal
  torque+=Eigen::Vector3d(-msg->Ltorque*msg->contact_normal.x,-msg->Ltorque*msg->contact_normal.y,-msg->Ltorque*msg->contact_normal.z); //not sure about the sign of Ltorque is negative as well

  state.wrench.force.x=force(0);
  state.wrench.force.y=force(1);
  state.wrench.force.z=force(2);
  state.wrench.torque.x=torque(0);
  state.wrench.torque.y=torque(1);
  state.wrench.torque.z=torque(2);


  c_state_pubs_[topic_id].publish(state);
}
//-------------------------------------------------------------------




